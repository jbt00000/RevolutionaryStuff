<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating"#>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ import namespace="System.Text" #>
<#+ // Start of class feature control block.  
void TransformSchemaMetaXml2Pocos(ITextTemplatingEngineHost host, string dbContextNamespace, string databaseContextClassName, IEnumerable<string> extraNamespaces, string iMyTenantFinder)  
{  
    string xmlFile = System.IO.Path.GetFileNameWithoutExtension(host.TemplateFile)+".xml";
	var schemaMetaFullPath = host.ResolvePath(xmlFile);
	var doc = XDocument.Load(schemaMetaFullPath);
	var tablesInDbContext = new HashSet<string>(new CaseInsensitiveStringEqualityComparer());
    var fluentKeysByEntity = new Dictionary<string, List<string>>();
	var fluentRelationships = new List<string>();
	var queryFiltersAny = new List<string>();
	var queryFilters = new List<string>();
	var queryFiltersNoTenantFinder = new List<string>();

    // Create Query Filters
    foreach (var z in doc.XPathSelectElements("/SchemaMeta/Tables/Table[Properties/Property/@name='GeneratePoco'=\"zzd\"]"))
    {
	    if (GetPropertyValue(z, "GeneratePoco")!="1") continue;

	    var className = GetClassName(z);
	    string propertyName;
	    var hasRowStatus= HasRowStatus(z, out propertyName);
	    var hasTenant = HasTenant(z);

        var filterQueryPrefix= $"modelBuilder.Entity<{className}>().HasQueryFilter(x =>";
        var filterQueryPostfix= ");";
        var rowStatusQuery= $"x.{propertyName} == TraffkHelpers.RowStatusValid";
        var tenantQuery = "x.TenantId == MyTenantId";

	    if(hasRowStatus)
        {
            queryFiltersNoTenantFinder.Add($"{filterQueryPrefix} {rowStatusQuery}{filterQueryPostfix}");        
        }

	    if(hasRowStatus && hasTenant)
        {
            queryFilters.Add($"{filterQueryPrefix} {rowStatusQuery} && {tenantQuery}{filterQueryPostfix}");
        }
	    else if(hasRowStatus)
        {
		    queryFilters.Add($"{filterQueryPrefix} {rowStatusQuery}{filterQueryPostfix}");
        }
	    else if(hasTenant)
        {
            queryFilters.Add($"{filterQueryPrefix} {tenantQuery}{filterQueryPostfix}");
        }

        var filterByPropertyName = GetSimpleQueryFilters(z);
        foreach (var kvp in filterByPropertyName)
        {
		    queryFiltersAny.Add($"{filterQueryPrefix} x.{kvp.Key} {kvp.Value});");        
        }
    }

#>  
/*
This was autogenerated
DO NOT MODIFY BY HAND!!!
T4 File: SchemaMeta2DbContext.t4
XML File: <#=schemaMetaFullPath#>
Generation Time: <#=DateTime.Now#>
*/
using Microsoft.AspNetCore.Identity;
using Microsoft.Data.SqlClient;
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using RevolutionaryStuff.Core;
using RevolutionaryStuff.Core.ApplicationParts;
using RevolutionaryStuff.Core.Database;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using System.Runtime.Serialization;
<#+
if (extraNamespaces!=null)
{
    foreach (var ns in extraNamespaces)
    {
#>
using <#=ns#>;
<#+    
    }
}
#>

namespace <#=dbContextNamespace#>
{
    public partial class <#=databaseContextClassName#>
    {
        partial void OnModelCreatingPartial(ModelBuilder modelBuilder);

		protected override void OnModelCreating(ModelBuilder modelBuilder)
		{
            base.OnModelCreating(modelBuilder);
<#+
foreach (var z in doc.XPathSelectElements("/SchemaMeta/Tables/Table[Properties/Property/@name='AddToDbContext']"))
{
			if (GetPropertyValue(z, "AddToDbContext")!="1") continue;
			var descriminator = z.XPathSelectElements("Columns/Column[Properties/Property/@name='IsInheritanceDiscriminatorField']").FirstOrDefault() as XElement;
			if (descriminator==null) continue;
			var superclass = GetClassName(z);
			var descriminatorProperty = descriminator.Attribute("name").Value;
			if (z.XPathSelectElements("Columns/Column[@name='"+descriminatorProperty+"']/Properties/Property[@name='EnumType']").FirstOrDefault()!=null)
			{
				descriminatorProperty += "RawValue";
			}
#>
			modelBuilder.Entity<<#=superclass#>>()
				.HasDiscriminator<string>(nameof(<#=superclass#>.<#=descriminatorProperty#>))
<#+
	foreach (XElement icp in z.XPathSelectElements("Properties/Property"))
	{
		var icpn = RightOf(icp.Attribute("name").Value, "InheritanceClass:");
		if (icpn==null) continue;
		icpn = LeftOf(icpn, ",");
#>
				.HasValue<<#=icpn#>>("<#=icp.Attribute("value").Value#>")
<#+
	}
#>
				;
<#+
}
#>
            AddPrecision(modelBuilder);
            AddFluentKeys(modelBuilder);
			AddFluentRelationships(modelBuilder);
			AddQueryFilters(modelBuilder);
            OnModelCreatingPartial(modelBuilder);
		}

		#region Collections
<#+

foreach (var z in doc.XPathSelectElements("/SchemaMeta/Sprocs/Sproc[Properties/Property/@name='GeneratePoco'=\"1\"]/ResultSets/ResultSet[@isError='0' and @colCount > 0]"))
{
#>		
		public DbSet<<#=GetClassName(z)#>> <#=z.Parent.Parent.Attribute("name").Value#> { get; set; } // table value function
<#+
}


foreach (var z in doc.XPathSelectElements("/SchemaMeta/Tables/Table[Properties/Property/@name='AddToDbContext']").OrderBy(wq=>GetClassName(wq)))
{
		if (GetPropertyValue(z, "AddToDbContext")!="1") continue;
        var keyCount = z.XPathSelectElements(".//Column[@isPrimaryKey='1']").Count() + z.XPathSelectElements(".//Column/Properties/Property[@name='CustomAttribute' and @value='Key']").Count();
		var containerType = keyCount==0?"DbSet":"DbSet";

		var schemaTable = GetAttrVal(z, "schema") + "." + GetAttrVal(z, "name");
		tablesInDbContext.Add(schemaTable);
#>		
		public virtual <#=containerType#><<#=GetClassName(z)#>> <#=z.Attribute("name").Value#> { get; set; } //<#=schemaTable#>

<#+
	foreach (XElement icp in z.XPathSelectElements("Properties/Property"))
	{
		var icpn = RightOf(icp.Attribute("name").Value, "InheritanceClass:");
		if (icpn==null) continue;
		var className = LeftOf(icpn, ",");
		var collName = RightOf(icpn, ",");
		if (collName==null) continue;
#>
		public virtual <#=containerType#><<#=className#>> <#=collName#> { get; set; }

<#+
	}
}
#>
		#endregion

		#region Sprocs

<#+
foreach (var z in doc.XPathSelectElements("/SchemaMeta/Sprocs/Sproc[Properties/Property/@name='AddToDbContext']"))
{
	var sprocType = GetPropertyValue(z, "SprocType") ?? "NonQuery";
	if (sprocType=="void") sprocType = "NonQuery";
    if (sprocType=="NonQuery")
    {
        var rsets = z.XPathSelectElements("ResultSets/ResultSet").ToList();
        if (rsets.Count==1)
        {
            var rs0 = rsets[0];
            var rs0name = GetClassName(rs0);
            if (rs0name!=null && GetAttrVal(rs0, "isError")=="0")
            {
                sprocType = "Collection:"+rs0name;
            }        
        }
    }
	var isCollection = sprocType.StartsWith("Collection");
	var isSpecificCollection = sprocType.StartsWith("Collection:");
	var tenantIdParameterName = GetPropertyValue(z, "TenantIdParameterName");
	string collectionType = null;
	string collectionTypeConstraint = "";
	if (isSpecificCollection)
	{
		collectionType = sprocType.Substring(11);
	}
	else if (isCollection)
	{
		collectionType = "TItem";
		collectionTypeConstraint = "where TItem : new()";
	}
	var isReader = sprocType == "Reader";
	var isNonQuery = sprocType == "NonQuery";
	var sprocNameSuffix = isReader ? "Reader" : "";
	var accessModifier = GetAccessModifier(z);
#>
		<#=accessModifier#> async Task<ConnectionHelpers.Result<#=isCollection?"<"+collectionType+">":""#>> <#=GetSprocName(z)#><#=sprocNameSuffix#>Async<#=collectionTypeConstraint==""?"":"<"+collectionType+">"#>(<#+
		int argNum = 0;
foreach (var a in z.XPathSelectElements("Args/Arg"))
{
	bool nullable = true;
	string dataType = GetPropertyValue(a, "EnumType") ?? SqlTypeToClrType(GetAttrVal(a, "sqlType"));
	if (dataType=="string")
	{
		nullable = false;	
	}
	var memberName = GetAttrVal(a, "name").Substring(1);
	if (memberName==tenantIdParameterName) continue;
	#><#=argNum==0?"":", "#><#=dataType#><#=nullable?"?":""#> <#=memberName#> = null<#+
	++argNum;
}
if (argNum>0)
{
#>, <#+
}
#> TimeSpan? commandTimeout=null<#+
if (isReader)
{#>, params Action<IDataReader>[] actions<#+}#>) <#=collectionTypeConstraint#>
		{
            var ps = new SqlParameter[]
                {
<#+foreach (var a in z.XPathSelectElements("Args/Arg"))
{
	var memberName = GetAttrVal(a, "name").Substring(1);
	bool nullable = true;
	bool convertToString = GetPropertyValue(a, "EnumType") != null;
	switch (GetAttrVal(a, "sqlType"))
	{
		case "nvarchar":
		case "varchar":
			nullable = false;
			break;
	}
	string direction = GetAttrVal(a, "mode");
	switch (direction)
	{
		case "INOUT":
			direction = "ParameterDirection.InputOutput";
			break;
		case "OUT":
			direction = "ParameterDirection.Output";
			break;
		case "IN":
			direction = "ParameterDirection.Input";
			break;
		default:
			throw new Exception("unrecognized direction "+direction);
	}
    var maxLen = GetAttrVal(a, "maxLen");
    if (maxLen!=null && !int.TryParse(maxLen, out int junk))
    {
        maxLen = null;
    }
#>                    new SqlParameter("<#=GetAttrVal(a, "name")#>", <#=memberName#>==null ? DBNull.Value:(object) <#=memberName#><#=convertToString?".ToString()":""#>){Direction=<#=direction#><#=(maxLen==null?"":", Size="+maxLen+"")#>},
<#+
}
#>
                };
            var conn = Database.GetDbConnection();
            await EnsureConnectedAsync(conn);
<#+
			if (isNonQuery)
			{
#>            return await conn.ExecuteNonQueryAsync(null, "<#=GetAttrVal(z, "schema")#>.<#=GetAttrVal(z, "name")#>", commandTimeout, ps);
<#+
			}
			else if (isReader)
			{
#>            return await conn.ExecuteReaderForEachAsync(null, "<#=GetAttrVal(z, "schema")#>.<#=GetAttrVal(z, "name")#>", commandTimeout, ps, actions);
<#+		
			}
			else if (isCollection)
			{
#>            return await conn.ExecuteReaderAsync<<#=collectionType#>>(null, "<#=GetAttrVal(z, "schema")#>.<#=GetAttrVal(z, "name")#>", commandTimeout, ps);
<#+			
			}
#>
		}

<#+
}
#>
		#endregion

	}
<#+
var keylessEntities = new List<string>();
var classElements = new List<System.Xml.Linq.XElement>();
classElements.AddRange(doc.XPathSelectElements("/SchemaMeta/Tables/Table[Properties/Property/@name='GeneratePoco' and Properties/Property/@value='1']"));
classElements.AddRange(doc.XPathSelectElements("/SchemaMeta/Sprocs/Sproc[Properties/Property/@name='GeneratePoco' and Properties/Property/@value='1']/ResultSets/ResultSet[@isError='0' and @colCount > 0]"));
foreach (var z in classElements)
{
	var classNames = new List<string>();
	classNames.Add(GetClassName(z));
	bool inheritance = false;
	string inheritanceClassDiscriminatorValue = null;
	foreach (XElement icp in z.XPathSelectElements("Properties/Property"))
	{
		var icpn = RightOf(icp.Attribute("name").Value, "InheritanceClass:");
		if (icpn==null) continue;
		classNames.Add(LeftOf(icpn, ","));
		inheritanceClassDiscriminatorValue = icp.Attribute("value").Value;
		inheritance = true;
	}
	if (inheritance) classNames.Add(classNames[0]+"AllFields");
	for (int classNameIndex=0;classNameIndex<classNames.Count;++classNameIndex)
	{
	var className = classNames[classNameIndex];
	var isAllFields = classNameIndex==classNames.Count-1 && classNameIndex>0;
	var constructorAccessModifier = isAllFields ? "private" : "public";
#>

<#+
	string comment;
	comment = GetPropertyValue(z, "Comment");

	if (comment!=null)
	{
#>
	/// <summary>
	/// <#=comment#>
	/// </summary>
<#+
	}

	var isAbstract = inheritance == true;
	var jsonSettingsPresavers = new Dictionary<string, string>();
	string superclass = null;
	if (inheritance && className != classNames[0])
	{
		superclass = classNames[0];
	}
	var copyConstructorFieldNames = new List<string>();
	string primaryKeyPropertyName = null;
	string primaryKeyTypeName = null;
	int keyParts  = 0;
	foreach (var pkc in z.XPathSelectElements("Columns/Column[@isPrimaryKey=\"1\" or Properties/Property[@name=\"CustomAttribute\" and @value=\"Key\"]]"))
	{
		primaryKeyTypeName = SqlTypeToClrType(GetAttrVal(pkc, "sqlType"));
		++keyParts;
	}
	if (keyParts>1)
	{
		primaryKeyTypeName  = null;
	}
    else if (keyParts==0)
    {
        keylessEntities.Add(className);
    }
	var keyPropertyNames = new List<string>();
	var baseClass = GetPropertyValue(z, "BaseClass");
	var implements = GetPropertyValue(z, "Implements");
	var validators = new List<string>();
    if (z.Name=="Table")
    {
#>
	[Table("<#=GetAttrVal(z, "name")#>", Schema = "<#=GetAttrVal(z, "schema")#>")]
<#+
    }
	if (GetPropertyValue(z, "CustomAttribute")!=null)
	{
#>	[<#=GetPropertyValue(z, "CustomAttribute")#>]
<#+		
	}
	if (superclass==null)
	{
#>
	public <#=isAbstract?"abstract ":""#>partial class <#=className#> : <#=baseClass==null?"":baseClass+", "#>IRdbDataEntity, IValidate, IPreSave<#=implements==null?"":", "+implements#><#=primaryKeyTypeName==null?"":", IPrimaryKey<"+primaryKeyTypeName+">"#>
	{
        public static readonly <#=className#>[] None = new <#=className#>[0];

<#+	
	}
	else
	{
#>
	public partial class <#=className#> : <#=superclass#>
	{
        public static new readonly <#=className#>[] None = new <#=className#>[0];

<#+		
	}
#>

<#+
if (superclass==null) foreach (var ip in z.XPathSelectElements("Collections/Collection"))
{
	var schemaTable = GetAttrVal(ip, "schema") + "." + GetAttrVal(ip, "table");
	if (!tablesInDbContext.Contains(schemaTable))
	{
	#>
		//skipped: <#=schemaTable#>

<#+
	 continue;
	}

    var ipSchema = GetAttrVal(ip, "schema");
    var ipTable = GetAttrVal(ip, "table");
    var ipColumn = GetAttrVal(ip, "column");
	var inversePropertyTypeName = GetClassName(doc, ipSchema, ipTable);
	var inversePropertyFieldName = GetPropertyNameFromColumnName(ipColumn)+inversePropertyTypeName+"s";

    var xp = "/SchemaMeta/Tables/Table[@name='"+ipTable+"' and @schema='"+ipSchema+"']/Columns/Column[@name='"+ipColumn+"']";
    var it = doc.XPathSelectElements(xp).FirstOrDefault();
    var accessModifier = GetAccessModifier(it);
    //if (accessModifier=="missing") continue;
	copyConstructorFieldNames.Add(inversePropertyFieldName);

	//https://github.com/aspnet/EntityFrameworkCore/issues/9180
	var mb = string.Format(
		"modelBuilder.Entity<{0}>(e=>e.HasOne(r=>r.{1}).WithMany(u=>u.{2}).HasForeignKey(r=>r.{3}));",
		inversePropertyTypeName,
		GetPropertyNameFromColumnName(GetAttrVal(ip, "column")),
		inversePropertyFieldName,
		GetAttrVal(ip, "column")
		);
	fluentRelationships.Add(mb);
#>

		//<#=mb#>
		[InverseProperty(nameof(<#=inversePropertyTypeName#>.<#=GetPropertyNameFromColumnName(GetAttrVal(ip, "column"))#>))]
		[JsonIgnore]
        [IgnoreDataMember]
        public List<<#=inversePropertyTypeName#>> <#=inversePropertyFieldName#> { get; set; } = new List<<#=inversePropertyTypeName#>>();

<#+
}
int lastPosition = -1;
foreach (var f in z.XPathSelectElements("Columns/Column"))
{
    var position = GetAttrValAsInt(f, "position");
    if (position==lastPosition) continue; //To fix the bug where db.SchemaMeta can return the same column twice
    lastPosition = position;
	var accessModifier = GetAccessModifier(f);
	if (accessModifier=="missing") continue;
	var inheritanceModifier  = GetPropertyValue(f, "InheritanceModifier");
	if (inheritance)
	{
		if (GetPropertyValue(f, "IsInheritanceDiscriminatorField")=="1")
		{
//			continue;
		}
		bool isInheritedField = false;
		bool isInheritedFieldInThisSubsclass = isAllFields;
		foreach (XElement prop in f.XPathSelectElements("Properties/Property[@name='InheritanceField']"))
		{
			var ifcn = GetAttrVal(prop, "value");
			isInheritedField = true;
			if (ifcn.Split(',').Contains(className))
			{
				isInheritedFieldInThisSubsclass = true;
				break;
			}
		}	
		if (isInheritedField && !isInheritedFieldInThisSubsclass) continue;
		if (!isInheritedField && superclass!=null) continue;
	}
	string propertyName = MakeIdentifierCSharpFriendly(GetAttrVal(f, "name"));
	if (propertyName==className)
	{
		propertyName = propertyName + "Property";
	}
	comment = GetPropertyValue(f, "MS_Description");
	var dataAnnotation = GetPropertyValue(f, "DataAnnotation");
	var customAttributeNames = GetPropertyValue(f, "CustomAttribute");
	var displayName = GetPropertyValue(f, "DisplayName") ?? ToTitleFriendlyString(propertyName);
	var sampleData = GetPropertyValue(f, "SampleData");
	bool isPrimaryKey = GetAttrValAsBool(f, "isPrimaryKey") || customAttributeNames=="Key";
	var addToCopyConstructor = !isPrimaryKey;
	if (isPrimaryKey)
	{
		primaryKeyPropertyName = propertyName;
	}
	bool isNullable;
	string maxLen;
	string jsonSettingsClass;
	string dataTypeAttributeValue;
    string sqlType;
	string dataType = GetClrTypeFromColumn(f, out isNullable, out maxLen, out jsonSettingsClass, out dataTypeAttributeValue, out sqlType);
	if (dataType==null) continue;
	if (isPrimaryKey && keyParts==1)
	{
#>
		object IPrimaryKey.Key { get { return <#=propertyName#>; }}
	
		<#=primaryKeyTypeName#> IPrimaryKey<<#=primaryKeyTypeName#>>.Key { get { return <#=propertyName#>; }}

<#+
	}

	if (comment!=null)
	{
#>
		/// <summary>
		/// <#=comment#>
		/// </summary>
		[Description("<#=EscapeForCSharpStringEmbed(comment)#>")]
<#+
		if (displayName==null)
		{
#>		[Display(Description = "<#=EscapeForCSharpStringEmbed(comment)#>")]
<#+	
		}
	}
	if (displayName!=null)
	{
#>		[DisplayName("<#=EscapeForCSharpStringEmbed(displayName)#>")]
<#+	
		if (comment==null)
		{
#>		[Display(Name = "<#=EscapeForCSharpStringEmbed(displayName)#>")]
<#+	
		}
	}
	if (displayName!=null && comment!=null)
	{
#>		[Display(Name = "<#=EscapeForCSharpStringEmbed(displayName)#>", Description = "<#=EscapeForCSharpStringEmbed(comment)#>")]
<#+	
	}
	string enumType = GetPropertyValue(f, "EnumType");
	if (enumType!=null)
	{
		var enumPropertyName = propertyName;
		propertyName += "RawValue";
        if (dataType=="string")
        {
#>
		[NotMapped]
		public <#=enumType#> <#=enumPropertyName#>
        {
            get
            {
                if (Enum.TryParse(<#=propertyName#>, true, out <#=enumType#> e)) return e;
                return 0;
            }
            set { <#=propertyName#> = value.ToString(); }
        }

<#+
        }
        else
        {
#>
		[NotMapped]
		public <#=enumType#> <#=enumPropertyName#>
        {
            get => (<#=enumType#>) <#=propertyName#>;
            set { <#=propertyName#> = (<#=dataType#>)value; }
        }

<#+
        }
	}
	if (jsonSettingsClass!=null)
	{
		var settingsPropertyName = propertyName;
		var settingsFieldName = settingsPropertyName+"_p";
		propertyName = propertyName+"Json";
		jsonSettingsPresavers[settingsFieldName] = propertyName;
#>
		partial void On<#=settingsPropertyName#>Deserialized();

        [NotMapped]
        public <#=jsonSettingsClass#> <#=settingsPropertyName#>
        {
            get
            {
                if (<#=settingsFieldName#> == null)
                {
                    <#=settingsFieldName#> = <#=jsonSettingsClass#>.CreateFromJson(<#=propertyName#>) ?? new <#=jsonSettingsClass#>();
					On<#=settingsPropertyName#>Deserialized();
                }
                return <#=settingsFieldName#>;
            }
            set { <#=settingsFieldName#> = value; }
        }
        private <#=jsonSettingsClass#> <#=settingsFieldName#>;

<#+
	}
	if (sampleData!=null)
	{
#>		[SampleData("<#=sampleData#>")]
<#+
	}
	if (dataType=="string" && !isNullable)
	{
		validators.Add("Requires.NonNull("+propertyName+", nameof("+propertyName+"));");
#>		[NotNull]
		[Required]
<#+
	}
	if (isPrimaryKey)
	{
        fluentKeysByEntity[className] = keyPropertyNames;
		keyPropertyNames.Add(propertyName);
		if (customAttributeNames!="Key" && keyParts==1){
#>		[Key]
<#+
		}
	}
	if (dataAnnotation!=null)
	{
#>		[<#=dataAnnotation#>]
<#+			
	}
	if (customAttributeNames!=null)
	{
#>		[<#=customAttributeNames#>]
<#+		
	}
	if (dataTypeAttributeValue!=null)
	{
#>		[DataType(<#=dataTypeAttributeValue#>)]
<#+	
	}
	if (dataType=="string" && maxLen != null)
	{
		validators.Add("Requires.Text("+propertyName+", nameof("+propertyName+"), true, 0, "+maxLen+");");
#>		[MaxLength(<#=maxLen#>)]
<#+
	}
	if (propertyName.StartsWith("CreatedAt", System.StringComparison.CurrentCultureIgnoreCase) ||
		GetAttrValAsBool(f, "isComputed") ||
		GetImplementsRowStatusSemantics(f)
	)
	{
		addToCopyConstructor = false;
#>		[DatabaseGenerated(DatabaseGeneratedOption.Computed)]
<#+
	}
	else if (GetAttrVal(f, "isIdentity")=="1")
	{
#>		[DatabaseGenerated(DatabaseGeneratedOption.Identity)]
<#+
	}
	string defaultValue = GetDefaultValue(f, dataType);
	if (defaultValue!=null)
	{
		defaultValue = "= "+defaultValue+";";
	}
	else
	{
		defaultValue = GetAttrVal(f, "default");
		if (defaultValue!=null)
		{
			defaultValue = "//= "+defaultValue+";";
		}
	}
#>
		[Column("<#=GetAttrVal(f, "name")#>"<#+ if (sqlType.IndexOf("(")>0){#>, TypeName="<#=sqlType#>"<#+}#>)]
		<#=accessModifier#> <#=inheritanceModifier==null?"":inheritanceModifier+" "#><#=dataType#> <#=propertyName#> {<#=inheritanceModifier=="override"?" get => base."+propertyName+"; set => base."+propertyName+"=value; ":" get; set; "#>} <#=(defaultValue??"")#>	

<#+
	if (GetAttrVal(f, "refTable")!=null || GetPropertyValue(f, "LinksTo")!=null)
	{
		var refSchema = GetAttrVal(f, "refSchema") ?? LeftOf(GetPropertyValue(f, "LinksTo"), ".");
		var refTable = GetAttrVal(f, "refTable") ?? RightOf(LeftOf(GetPropertyValue(f, "LinksTo"), "("), ".");
        if (tablesInDbContext.Contains(refSchema+"."+refTable))
        {
#>
		//LinksTo:<#=refSchema#>.<#=refTable#>
		[ForeignKey("<#=GetAttrVal(f, "name")#>")]
		[JsonIgnore]
        [IgnoreDataMember]
		<#=accessModifier#> <#=GetClassName(doc, refSchema, refTable)#> <#=GetPropertyNameFromColumnName(propertyName)#> { get; set; } 

<#+	
        }
        else
        {
#>
		//MissingLinksTo:<#=refSchema#>.<#=refTable#>

<#+	
        }
	}
	if (propertyName.EndsWith("Utc", System.StringComparison.CurrentCultureIgnoreCase) && dataType.StartsWith("DateTime", System.StringComparison.CurrentCultureIgnoreCase))
	{
		var localTimePropertyName = RemoveFinalNCharacters(propertyName,3);
#>

		[DisplayName("<#=ToTitleFriendlyString(localTimePropertyName)#>")]
		[NotMapped]
		[JsonIgnore]
		[DataType(DataType.DateTime)]
        [IgnoreDataMember]
		<#=accessModifier#> <#=dataType#> <#=localTimePropertyName#> => <#=propertyName#><#=isNullable?"?":""#>.ToLocalTime();

<#+	
	}
	if (addToCopyConstructor)
	{
		copyConstructorFieldNames.Add(propertyName);
	}
}
#>
		partial void OnToString(ref string extras);

        public override string ToString()
		{
			string extras = null;
			OnToString(ref extras);
			return $"{GetType().Name} <#+
foreach (var kpn in keyPropertyNames)
{
#><#=kpn#>={<#=kpn#>}<#+
}
#> {extras}";
		}

		partial void OnConstructed();
	
		<#=constructorAccessModifier#> <#=className#>()
			: this(null)
		{}

		<#=constructorAccessModifier#> <#=className#>(<#=className#> other, bool copyKey=false)<#=superclass==null?"":"\n\t\t\t: base(other)"#>
		{
			if (other!=null)
			{
<#+if(primaryKeyPropertyName!=null){
#>
				if (copyKey)
				{
					<#=primaryKeyPropertyName#> = other.<#=primaryKeyPropertyName#>;
				}
<#+
}
foreach (var ccfn in copyConstructorFieldNames)
{
#>
				<#=ccfn#> = other.<#=ccfn#>;
<#+
}
#>			}
			OnConstructed();
		}

		partial void PartialPreSave();

<#+	
if (superclass==null)
{
#>		void IPreSave.PreSave()
        {
			OnPreSave();
		}

		protected virtual void OnPreSave()
		{
<#+
}
else
{
#>		protected override void OnPreSave()
		{
			base.OnPreSave();
<#+	
}
#>
<#+
foreach (var kvp in jsonSettingsPresavers)
{
#>
            if (<#=kvp.Key#> != null)
            {
				var json = <#=kvp.Key#>.ToJson();
				if (<#=kvp.Value#> != json)
				{
					<#=kvp.Value#> = json;
				}				 
            }
<#+}
#>
			PartialPreSave();
        }

		partial void PartialValidate();

<#+	
if (superclass==null)
{
#>		public virtual void Validate()
        {
<#+
}
else
{
#>		public override void Validate()
        {
			base.Validate();
<#+
}
#>
<#+
foreach (var v in validators)
{
#>
			<#=v#>
<#+}
#>
			PartialValidate();
        }
	}//end of entity class <#=className#>

<#+}
}
#>


    public partial class <#=databaseContextClassName#>
    {
        public static TimeSpan ConnectingWaitTimeout = TimeSpan.FromMilliseconds(100);

        public static int ConnectingWaitSegments = 10;

        private async Task EnsureConnectedAsync(System.Data.Common.DbConnection conn)
        {
			for (int x=0;conn.State == ConnectionState.Connecting && x < ConnectingWaitSegments; ++x)
			{
                await Task.Delay((int) (ConnectingWaitTimeout.TotalMilliseconds / ConnectingWaitSegments));
			}        
        }

        private int MyTenantId
        {
            get
            {
                var t =  <#=iMyTenantFinder==null?"Task.FromResult(-1)":"(("+iMyTenantFinder+")this).GetTenantIdAsync()"#>;
                if (!t.IsCompleted)
                {
                    t.ExecuteSynchronously();
                }
                return t.Result;
            }
        }

        partial void OnAddPrecision(ModelBuilder modelBuilder);

        private void AddPrecision(ModelBuilder modelBuilder)
        {
            OnAddPrecision(modelBuilder);        
        }

        partial void OnAddFluentKeys(ModelBuilder modelBuilder);

        private void AddFluentKeys(ModelBuilder modelBuilder)
        {
            OnAddFluentKeys(modelBuilder);        
<#+
foreach (var kvp in fluentKeysByEntity)
{
    if (kvp.Value.Count>1)
    {
#>
            modelBuilder.Entity<<#=kvp.Key#>>().HasKey(z => new {<#+ for (int q=0;q<kvp.Value.Count;++q){ #><#=(q==0?"":", ")#>z.<#=kvp.Value[q]#><#+ } #> });
<#+}
}
foreach (var z in keylessEntities)
{
#>
            modelBuilder.Entity<<#=z#>>(e => e.HasNoKey());
<#+}
#>
        }

        partial void OnAddFluentRelationships(ModelBuilder modelBuilder);

        private void AddFluentRelationships(ModelBuilder modelBuilder)
		{
            OnAddFluentRelationships(modelBuilder);
<#+
            fluentRelationships.Sort();
foreach (var r in fluentRelationships)
{
#>
			<#=r#>
<#+}
#>
		}

		partial void OnAddQueryFilters(ModelBuilder modelBuilder);

		private void AddQueryFilters(ModelBuilder modelBuilder)
		{
			OnAddQueryFilters(modelBuilder);
<#+
queryFiltersAny.Sort();
	foreach (var queryFilter in queryFiltersAny)
	{
	#>
			<#=queryFilter#>
<#+}
// Don't get tenantFinder if we have no query filters
if(queryFilters.Any() || queryFiltersNoTenantFinder.Any())
{
#>		   
			if (this is <#=iMyTenantFinder#>)
			{
	<#+
	queryFilters.Sort();
	foreach (var queryFilter in queryFilters)
	{
	#>
			<#=queryFilter#>
	<#+}
	#>
		}
			else
			{
	<#+
				queryFiltersNoTenantFinder.Sort();
	foreach (var queryFilter in queryFiltersNoTenantFinder)
	{
	#>
			<#=queryFilter#>
	<#+}
	#>
		}
<#+
} // ends // Don't get tenantFinder if we have no query filters	
#>
		}
    }

    public static class <#=databaseContextClassName#>TableValueFunctions
    {
<#+
foreach (var z in doc.XPathSelectElements("/SchemaMeta/Sprocs/Sproc[Properties/Property/@name='GeneratePoco'=\"1\"]/ResultSets/ResultSet[@isError='0' and @colCount > 0]"))
{
#>		
        public static IQueryable<<#=GetClassName(z)#>> Execute(this DbSet<<#=GetClassName(z)#>> q<#+foreach (var a in z.Parent.Parent.XPathSelectElements("Args/Arg")){#>, <#=SqlTypeToClrType(a.Attribute("sqlType").Value)#> <#=RightOf(a.Attribute("name").Value,"@")#><#+}#>)
            => q.FromSqlInterpolated($"select * from <#=z.Parent.Parent.Attribute("schema").Value#>.<#=z.Parent.Parent.Attribute("name").Value#>(<#+int argNum=0; foreach (var a in z.Parent.Parent.XPathSelectElements("Args/Arg")){#><#=((argNum++==0)?"":", ")#>{<#=RightOf(a.Attribute("name").Value,"@")#>}<#+}#>)");

<#+
}
#>
    }
}//end of file
<#+  
}  

private static readonly Regex LiteralDefaultValue = new Regex(@"^\s*'([^']*)'|(\d+)\s*$", RegexOptions.Compiled);

public string GetDefaultValue(XElement xel, string clrType)
{
	var dv = GetAttrVal(xel, "default");
	if (dv==null) return null;
        return GetDefaultValue(dv, clrType);
}
public string GetDefaultValue(string dv, string clrType)
{	
	while (dv[0]=='('&&dv[dv.Length-1]==')')
	{
		dv = dv.Substring(1, dv.Length-2);
	}
	switch (dv)
	{
		case "getutcdate()":
			return "DateTime.UtcNow";
	}
	var m = LiteralDefaultValue.Match(dv);
	if (m.Success)
	{
		if (clrType=="string")
		{
			return "\""+m.Groups[1].Value+"\"";		
		}
		else if (clrType=="int")
		{
			return m.Groups[2].Value;				
		}
		else if (clrType=="Guid")
		{
			return "Guid.Parse(\""+m.Groups[1].Value+"\")";
		}
		else if (clrType=="bool")
		{
			dv = m.Groups[2].Value;
			if (dv!=null && dv.Length==1)
			{
				return dv=="1"?"true":(dv=="0"?"false":null);
			} 
		}
	}
	return null;
}
public bool GetImplementsRowStatusSemantics(XElement xel)
{
	return GetPropertyValueAsBool(xel, "ImplementsRowStatusSemantics");
}
public string GetAccessModifier(XElement xel)
{
	var rss = GetImplementsRowStatusSemantics(xel);
	if (rss) return "public";
	var access = GetPropertyValue(xel, "AccessModifier") ?? GetPropertyValue(xel, "accessModifier") ?? "public";
	return access;
}
public int GetAttrValAsInt(XElement xel, string attrName, int missingVal=0)
{
	string val = GetAttrVal(xel, attrName);
    if (val==null || val=="") return missingVal;
	return int.Parse(val);
}
public bool GetAttrValAsBool(XElement xel, string attrName)
{
	string val = GetAttrVal(xel, attrName);
	return (val=="1") || (val=="true");
}
public string GetAttrVal(XElement xel, string attrName)
{
	var a = xel.Attribute(attrName);
	return a==null?null:a.Value;
}
public bool GetPropertyValueAsBool(XElement xel, string attrName)
{
	string val = GetPropertyValue(xel, attrName);
	return (val=="1") || (val=="true");
}
public string GetPropertyValue(XElement xel, string propertyName)
{
	var xpath = "Properties/Property[@name='"+propertyName+"']/@value";
	var res = ((IEnumerable<object>)xel.XPathEvaluate(xpath)).Cast<XAttribute>().FirstOrDefault();
	if (res==null) return null;
	return res.Value;
}
public string GetClassName(XElement tableElement)
{
	var name = GetPropertyValue(tableElement, "ClassName");
	if (name==null)
	{
        if (tableElement.Name=="Table")
        {
    		name = tableElement.Attribute("name").Value;        
        }
        else if (tableElement.Name=="ResultSet")
        {
    		name = string.Format("{0}_Result{1}", tableElement.Parent.Parent.Attribute("name").Value, tableElement.Attribute("resultSetNumber").Value);        
        }
		if (name.Length>3 && name.Substring(name.Length-3)=="ies")
		{
			name = name.Substring(0, name.Length-3)+"y";
		}
		else if (name[name.Length-1]=='s')
		{
			name = name.Substring(0, name.Length-1);
		}
	}
	return name;
}
public string GetSprocName(XElement tableElement)
{
	var name = GetPropertyValue(tableElement, "SprocName");
	if (name==null)
	{
		name = tableElement.Attribute("name").Value;
	}
	return name;
}
public string GetClassName(XDocument doc, string schemaName, string tableName)
{
	var tableElement = doc.XPathSelectElements("/SchemaMeta/Tables/Table[@name='"+tableName+"']").FirstOrDefault();
	return GetClassName(tableElement);
}

public static readonly Regex CSharpIdentifier = new Regex(@"^[_a-z][a-z0-9_]*$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
public static readonly Regex NonWordChars = new Regex(@"\W", RegexOptions.Compiled | RegexOptions.IgnoreCase);

public string MakeIdentifierCSharpFriendly(string identifier)
{
    if (!CSharpIdentifier.IsMatch(identifier))
    {
        identifier = NonWordChars.Replace(identifier, "_");        
    }
    return identifier;
}

public string GetPropertyNameFromColumnName(string propertyName)
{
	int lastN = 0;
    propertyName = MakeIdentifierCSharpFriendly(propertyName);
	if (propertyName.EndsWith("Id"))
	{
		lastN = 2;
	}
	else if (propertyName.EndsWith("Lid"))
	{
		lastN = 3;
	}
	else if (propertyName.EndsWith("Mcid") || propertyName.EndsWith("Ddim"))
	{
		lastN = 4;
	}
	else
	{
		return propertyName + "Entity";
	}
	return RemoveFinalNCharacters(propertyName, lastN);
}
public string RemoveFinalNCharacters(string s, int n)
{
	return s.Substring(0, s.Length-n);
}
public string RightOf(string s, string pivot)
{
	if (s==null) return null;
	var x = s.IndexOf(pivot);
	if (x<0) return null;
	return s.Substring(x+pivot.Length);
}
public string LeftOf(string s, string pivot)
{
	if (s==null) return null;
	var x = s.IndexOf(pivot);
	if (x<0) return s;
	return s.Substring(0, x);
}

public string GetClrTypeFromColumn(XElement f, out bool isNullable, out string maxLen, out string jsonSettingsClass, out string dataTypeAttributeValue, out string sqlType)
{
	dataTypeAttributeValue = null;
	isNullable = GetAttrValAsBool(f, "isNullable");
	maxLen = null;
	jsonSettingsClass = null;
	string dataType = null;
	bool canUseMaxLen = false;
    int precision = GetAttrValAsInt(f, "numericPrecision");
    int scale = GetAttrValAsInt(f, "numericScale");
	switch (GetAttrVal(f, "name"))
	{
		case "PhoneNumber":
			dataTypeAttributeValue = "DataType.PhoneNumber";
			break;
		case "PostalCode":
			dataTypeAttributeValue = "DataType.PostalCode";
			break;
	}
	switch (GetAttrVal(f, "domainName"))
	{
		case "Url":
			dataTypeAttributeValue = "DataType.Url";
			break;
		case "EmailAddress":
			dataTypeAttributeValue = "DataType.EmailAddress";
			break;
	}
    sqlType = GetAttrVal(f, "sqlType");
	switch (sqlType)
	{	
		case "uniqueidentifier":
			dataType = "Guid";
			break;
		case "smallint":
			dataType = "short" + (isNullable ? "?" : "");
			break;
		case "tinyint":
			dataType = "byte" + (isNullable ? "?" : "");
			break;
		case "money":
			dataType = "decimal" + (isNullable ? "?" : "");
			dataTypeAttributeValue = "DataType.Currency";
            sqlType += $"({precision}, {scale})";
			break;
		case "decimal":
		case "numeric":
			dataType = "decimal" + (isNullable ? "?" : "");
            sqlType += $"({precision}, {scale})";
			break;
		case "float":
			dataType = "double" + (isNullable ? "?" : "");
			break;
		case "int":
			dataType = "int" + (isNullable ? "?" : "");
			break;
		case "bigint":
			dataType = "long" + (isNullable ? "?" : "");
			break;
		case "char":
			canUseMaxLen = true;
			dataType = "string";
			//could not be mapped, because it is of type 'char' which is not a supported primitive type or a valid entity type
			//https://github.com/aspnet/EntityFrameworkCore/issues/9447
			//todo: add a [NotNullable] attribute to this declaration... or a max/min size
			//dataType = isNullable ? "string" : "char";
			break;
		case "bit":
			dataType = "bool" + (isNullable ? "?" : "");
			break;
		case "datetime2":
		case "datetime":
			dataTypeAttributeValue = "DataType.DateTime";
			dataType = "DateTime" + (isNullable ? "?" : "");
			break;
		case "date":
			dataTypeAttributeValue = "DataType.Date";
			dataType = "DateTime" + (isNullable ? "?" : "");
			break;
		case "varbinary":
		case "binary":
            canUseMaxLen = true;
			dataType = "byte[]";
			break;
		case "timestamp":
			dataType = "byte[]";
			break;
		case "xml":
			dataType = "string";
			break;
		case "nvarchar":
		case "varchar":
			canUseMaxLen = true;
			dataType = "string";
			jsonSettingsClass = GetPropertyValue(f, "JsonSettingsClass");
			break;
		//can't be mapped yet...
		case "geography":
			return null;
		default:
			dataType = "object";
			break;
	}
	if (canUseMaxLen)
	{
		maxLen = GetAttrVal(f, "maxLen");
		if (maxLen=="-1")
        {
            sqlType += $"(max)";
            maxLen = null;
        }
        else
        {
            sqlType += $"({maxLen})";
        }
	}
	return dataType;
}
public string SqlTypeToClrType(string sqlType)
{
	switch (sqlType)
	{
		case "uniqueidentifier":
			return "Guid";
		case "smallint":
			return "short";
		case "tinyint":
			return "byte";
		case "money":
		case "decimal":
		case "numeric":
			return "decimal";
		case "float":
			return "double";
		case "int":
			return "int";
		case "bigint":
			return "long";
		case "char":
			return "string";
			//return "char";
		case "bit":
			return "bool";
		case "binary":
		case "timestamp":
			return "byte[]";
		case "datetime2":
		case "datetime":
		case "date":
			return "DateTime";
		case "xml":
		case "nvarchar":
		case "varchar":
			return "string";
		default:
			return "object";
	}	
}
public static string EscapeForCSharpStringEmbed(string s)
{
	if (s==null) return null;
	return s.Replace("\\","\\\\").Replace("\"", "\\\"");
//	return System.Security.SecurityElement.Escape(s);
}
public static string ToTitleFriendlyString(string s)
{
    var sb = new StringBuilder();
    bool lastWasUpper = false;
    bool lastWasUnderscore = false;
    for (int x = 0; x < s.Length; ++x)
    {
        var ch = s[x];
        if (char.IsUpper(ch))
        {
            if (!lastWasUpper && x>0)
            {
                sb.Append(' ');
            }
            lastWasUpper = true;
            lastWasUnderscore = false;
        }
        else if (ch == '_')
        {
            ch = ' ';
            lastWasUnderscore = true;
        }
        else
        {
            if (lastWasUnderscore || x==0)
            {
                ch = char.ToUpper(ch);
            }
            lastWasUpper = false;
            lastWasUnderscore = false;
        }
        sb.Append(ch);
    }
    return sb.ToString();
}

public IDictionary<string, string> GetSimpleQueryFilters(XElement z) 
{
    var d = new Dictionary<string, string>();
    foreach (XElement rowStatus in z.XPathSelectElements("Columns/Column[Properties/Property/@name='SimpleQueryFilter']"))
    {
	    var propertyName = rowStatus.Attribute("name").Value;    
        var test = GetPropertyValue(rowStatus, "SimpleQueryFilter");		
        d[propertyName] = test;
    }
	return d;
}

public bool HasRowStatus(XElement z, out string propertyName) 
{
	propertyName = null;
	var rowStatus = z.XPathSelectElements("Columns/Column[Properties/Property/@name='ImplementsRowStatusSemantics']").FirstOrDefault() as XElement;
	if (rowStatus == null) return false;
	if (GetPropertyValue(rowStatus, "ImplementsRowStatusSemantics")!="1") return false;
		
	propertyName = rowStatus.Attribute("name").Value;
	return true;
}

public bool HasTenant(XElement z) 
{	
	if (GetPropertyValue(z, "Implements")!="ITraffkTenanted") return false;		
	return true;
}

public class CaseInsensitiveStringEqualityComparer : IEqualityComparer<string>
{
    public bool Equals(string x, string y)
        => 0 == string.Compare(x, y, true);

    public int GetHashCode(string obj)
    {
        if (obj == null) return 0;
        return obj.ToLowerInvariant().GetHashCode();
    }
}
#>